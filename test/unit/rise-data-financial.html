<!doctype html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../node_modules/mocha/mocha.js"></script>
  <script src="../../node_modules/chai/chai.js"></script>
  <script src="../../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>

  <script type="text/javascript">
    RisePlayerConfiguration = {
      isConfigured: () => true
    };
  </script>
  <script src="../../src/rise-data-financial-config.js" type="module"></script>
  <script src="../../src/rise-data-financial.js" type="module"></script>
</head>
<body>
<test-fixture id="test-block">
  <template>
    <rise-data-financial symbols="AA.N|.DJI" instrument-fields='["lastPrice", "netChange"]'></rise-data-financial>
  </template>
</test-fixture>

<script src="../data/realtime.js"></script>

<script>
  suite("rise-data-financial", () => {

    const fields = [ "lastPrice", "netChange" ],
      inst1 = {
        category: "Stocks",
        index: 0,
        name: "Alcoa",
        symbol: "AA.N",
        $id: "AA?N"
      },
      inst2 = {
        category: "Stocks",
        index: 1,
        name: "Dow Jones",
        symbol: ".DJI",
        $id: "?DJI"
      },
      instrument = {
        "AA?N": inst1
      },
      instruments = [
        inst1, inst2
      ];

    let element,
      clock,
      _resetStub;

    setup(() => {
      RisePlayerConfiguration.getDisplayId = () => {
        return "ABC123";
      };

      RisePlayerConfiguration.Logger = {
        info: () => {},
        warning: () => {},
        error: sinon.spy()
      };

      element = fixture("test-block");
      _resetStub = sinon.stub(element, "_reset");

    });

    teardown(() => {
      _resetStub.restore();
      RisePlayerConfiguration.getDisplayId = {};
      RisePlayerConfiguration.Logger = {};
    });

    suiteSetup( () => {
      clock = sinon.useFakeTimers();
    } );

    suiteTeardown( () => {
      clock.restore();
    } );

    suite( "Properties", () => {

      test( "should set symbols property", () => {
        assert.equal( element.symbols, "AA.N|.DJI" );
      } );

      test( "should set instrument fields array", () => {
        assert.deepEqual( element.instrumentFields, [ "lastPrice", "netChange" ] );
      } );

    } );

    suite( "_isValidSymbols", () => {

      test( "should return true if 'symbols' attribute is a non-empty String", () => {
        assert.isTrue( element._isValidSymbols( ".ABC" ) );
      } );

      test( "should return false if 'symbols' attribute is not a String or empty String", () => {
        assert.isFalse( element._isValidSymbols( 123 ) );
        assert.isFalse( element._isValidSymbols( [".abc|.def"] ) );
        assert.isFalse( element._isValidSymbols( "" ) );
      } );

      test( "should return true if 'symbols' attribute is a String containing values separated by '|'", () => {
        assert.isTrue( element._isValidSymbols( ".abc|.def|.ghi" ) );
      } );

      test( "should return false if 'symbols' attribute contains '|' with any empty value", () => {
        assert.isFalse( element._isValidSymbols( ".abc|" ) );
        assert.isFalse( element._isValidSymbols( "|.abc" ) );
        assert.isFalse( element._isValidSymbols( "|" ) );
        assert.isFalse( element._isValidSymbols( ".abc|.def||.ghi" ) );
      } );

    } );

    suite( "_isValidType", () => {

      test( "should return true if 'type' attribute is 'realtime'", () => {
        assert.isTrue( element._isValidType( "realtime" ) );
      } );

      test( "should return true if 'type' attribute is 'historical'", () => {
        assert.isTrue( element._isValidType( "historical" ) );
      } );

      test( "should return false when invalid", () => {
        assert.isFalse( element._isValidType( "test" ) );
      } );

    } );

    suite( "_refresh", () => {

      test( "should make a new request for data after 1 minute", () => {
        const stub = sinon.stub( element, "_getData" );

        element._refresh();

        assert.isFalse( stub.calledOnce );

        clock.tick( 60000 );

        assert.isTrue( stub.calledWith("AA.N|.DJI", {
          duration: "1M",
          type: "realtime"
        }, [ "lastPrice", "netChange" ]) );

        stub.restore();
      } );

    } );

    suite( "_getParams", () => {

      test( "should return query parameters object", () => {

        const callback = ( btoa( "request" + element._getKey() ) ).substr( 0, 10 ) + Math.random(),
          expected = {
            id: "ABC123",
            code: inst1.symbol,
            tq: "select lastPrice,netChange",
            tqx: "out:json;responseHandler:" + callback,
          };

        assert.deepEqual( element._getParams( fields, inst1.symbol, callback ), expected );
      } );

      test( "should return query parameters object with no 'tq' property", () => {
        const callback = ( btoa( "request" + element._getKey() ) ).substr( 0, 10 ) + Math.random(),
          expected = {
            id: "ABC123",
            code: inst1.symbol,
            tqx: "out:json;responseHandler:" + callback,
          };

        assert.deepEqual( element._getParams( [], inst1.symbol, callback ), expected );
      } );

    } );

    suite( "_getQueryString", () => {

      test( "should return query string for fetching a specific set of fields", () => {
        const expected = "select lastPrice,netChange";

        assert.equal( element._getQueryString( fields ), expected );
      } );

      test( "should return empty string if no parameter specified", () => {
        assert.equal( element._getQueryString( [] ), "" );
      } );

    } );

    suite( "_getKey()", () => {

      test( "should return correct key value when configured with defaults", () => {
        const expected = `risedatafinancial_${element.type}_${element.displayId}_${element.symbols}_${element.duration}`;
        assert.equal( element._getKey(), expected );
      } );

      test( "should return correct key value when configured different from defaults", () => {
        element.symbol = instrument.symbol;
        element.type = "historical";
        element.duration = "week";

        const expected = `risedatafinancial_${element.type}_${element.displayId}_${element.symbols}_${element.duration}`;
        assert.equal( element._getKey(), expected );
      } );

    });

    suite( "_getSerializedUrl", () => {

      test( "should return a serialized url with query params", () => {
        const callback = element._getCallbackValue( element._getKey() ),
          params = {
            id: "ABC123",
            code: inst1.symbol,
            tq: "select lastPrice,netChange",
            tqx: "out:json;responseHandler:" + callback,
          },
          expected = `https://contentfinancial2.appspot.com/data?id=ABC123&code=AA.N&tq=select%20lastPrice%2CnetChange&tqx=out%3Ajson%3BresponseHandler%3A${callback}`;

        assert.equal( element._getSerializedUrl( "https://contentfinancial2.appspot.com/data", params ), expected );
      } );

    });

    suite( "_getData", () => {
      let sandbox = sinon.createSandbox();

      const props = {
          type: "realtime",
          duration: "1M",
        };

      setup(()=>{
        sandbox.stub( element, "_sendFinancialEvent" );
        sandbox.stub( element, "_getSerializedUrl" );
      });

      teardown(()=>{
        sandbox.restore();
      });

      test( "should not execute if component configured with an invalid symbols and should raise data-error", () => {
        const stub = sinon.stub( element, "_getParams" );

        element._getData( 123, { type: "historical", duration: "1M" }, [] );

        assert.isFalse( stub.called );
        assert.isTrue( element._sendFinancialEvent.calledOnce );
        assert.deepEqual( element._sendFinancialEvent.getCall(0).args, ["data-error", "Invalid attributes."] );

        element._getData( ["test"], { type: "historical", duration: "1M" }, [] );

        assert.isFalse( stub.called );
        assert.isTrue( element._sendFinancialEvent.calledTwice );
        assert.deepEqual( element._sendFinancialEvent.getCall(1).args, ["data-error", "Invalid attributes."] );

        stub.restore();
      } );

      test( "should not execute if component configured with an invalid type and should raise data-error", () => {
        const stub = sinon.stub( element, "_getParams" );

        element._getData( element.symbols, { type: "invalid", duration: "1M" }, [] );

        assert.isFalse( stub.called );
        assert.isTrue( RisePlayerConfiguration.Logger.error.calledOnce );
        assert.isTrue( element._sendFinancialEvent.calledOnce );
        assert.deepEqual( element._sendFinancialEvent.getCall(0).args, ["data-error", "Invalid attributes."] );

        stub.restore();
      } );

      test( "should not execute if component configured for historical with an invalid duration and should raise data-error", () => {
        const stub = sinon.stub( element, "_getParams" );

        element._getData( element.symbols, { type: "historical", duration: "invalid" }, [] );

        assert.isFalse( stub.called );
        assert.isTrue( RisePlayerConfiguration.Logger.error.calledOnce );
        assert.isTrue( element._sendFinancialEvent.calledOnce );
        assert.deepEqual( element._sendFinancialEvent.getCall(0).args, ["data-error", "Invalid attributes."] );

        stub.restore();
      } );

      test( "should not raise data-error if valid attributes are provided", () => {
        element._getData( element.symbols, props, [] );

        assert.isFalse( RisePlayerConfiguration.Logger.error.called );
        assert.isFalse( element._sendFinancialEvent.called );
      } );

      test( "should call '_getSerializedUrl()' with realtime financial test server url", () => {
        element._getData( element.symbols, props, [] );

        assert.equal( element._getSerializedUrl.args[0][0], "https://contentfinancial2-test.appspot.com/data" );
      } );

      test( "should call '_getSerializedUrl()' with historical financial test server url", () => {
        props.type = "historical";
        element._getData( element.symbols, props, [] );

        assert.equal( element._getSerializedUrl.args[0][0], "https://contentfinancial2-test.appspot.com/data/historical" );
      } );

      test( "should call '_getSerializedUrl()' with correct params", () => {
        const expected = {
          id: "ABC123",
          code: "AA.N|.DJI",
          tq: "select lastPrice,netChange"
        };

        element._getData( element.symbols, props, fields );

        assert.equal( element._getSerializedUrl.args[0][1].id, expected.id );
        assert.equal( element._getSerializedUrl.args[0][1].code, expected.code );
        assert.equal( element._getSerializedUrl.args[0][1].tq, expected.tq );
        assert.include( element._getSerializedUrl.args[0][1].tqx, "out:json;responseHandler:" );
      } );

    } );

    suite( "_handleData", () => {

      test( "should send 'data-update' event with data", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            data: realTimeData.table,
            "user-config-change": false
          } );

          element.removeEventListener( "data-update", listener );
          done();
        };

        element.addEventListener( "data-update", listener );
        element._handleData( { detail: [ realTimeData ] } );
      } );

      test( "should send 'data-update' event with empty detail when no table provided", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, { "user-config-change": false } );

          element.removeEventListener( "data-update", listener );
          done();
        };

        element.addEventListener( "data-update", listener );
        element._handleData( { detail: [ {} ] } );
      } );

      test( "should send 'data-error' event with detail when 'errors' prop present in response detail", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            detailed_message: "400: Test error message",
            message: "Test error message"
          } );

          element.removeEventListener( "data-error", listener );
          done();
        };

        element.addEventListener( "data-error", listener );
        element._handleData( { detail: [ { errors: [ { detailed_message: "400: Test error message", message: "Test error message" } ] } ] } );
      } );

    } );

    suite( "_handleError", () => {

      setup(() => element._initialStart = false);

      test( "should send 'request-error' event with message after 5 failed retries", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            message: "Test error message"
          } );

          // retry count is reset
          assert.equal( element._financialRequestRetryCount, 0 );

          element.removeEventListener( "request-error", listener );
          element._getData.restore();

          done();
        };

        const stub = sinon.stub( element, "_getData" );

        element.addEventListener( "request-error", listener );

        // force value for observed financialErrorMessage property to emulate failed financial request
        element.financialErrorMessage = "Test error message";

        // account for 1 second delay
        clock.tick( 1000 );

        assert.equal( stub.callCount, 1 );
        assert.isTrue( stub.calledWith( element.symbols, {
          duration: "1M",
          type: "realtime"
        }, [ "lastPrice", "netChange" ]) );

        element.financialErrorMessage = "Test error message";

        // account for 1 second delay
        clock.tick( 1000 );

        assert.equal( stub.callCount, 2 );

        // emulate further retry failures
        for ( let i = 0; i < 3; i += 1 ) {
          element.financialErrorMessage = "Test error message";
          clock.tick( 1000 );
        }

        assert.equal( stub.callCount, 5 );

        element.financialErrorMessage = "Test error message";
        clock.tick( 1000 );
      } );

    } );

    suite( "_reset", () => {
      let getDataStub;

      setup( () => {
        getDataStub = sinon.stub( element, "_getData" );
      } );

      teardown( () => {
        getDataStub.restore();
      } );

      test( "should call _getData() if not initial start", () => {
        // need to remove the stub and add back on every test
        _resetStub.restore();
        element._initialStart = false;
        element._reset();

        assert.isTrue( getDataStub.calledOnce );
        assert.isTrue( element._userConfigChange );

        _resetStub = sinon.stub( element, "_reset" );
      } );

    } );

    suite( "ready", () => {
      test( "should set display id when a valid display id is provided", () => {
        assert.equal( element.displayId, "ABC123" );
      } );
    } );

    suite( "_handleStart", () => {

      test( "should call _getData() when this is the initial 'start'", () => {
        const stub = sinon.stub( element, "_getData" );

        const event = new CustomEvent( "start" );
        element.dispatchEvent( event );

        assert.isTrue( stub.calledWith( element.symbols, {
          duration: "1M",
          type: "realtime"
        }, [ "lastPrice", "netChange" ]) );

        assert.isFalse( element._initialStart, "_initialStart set to false" );

        stub.restore();
      } );

      test( "should not call _getData() when this is not the initial start", () => {
        const spy = sinon.stub( element, "_getData" );

        element._initialStart = false;

        const event = new CustomEvent( "getData" );
        element.dispatchEvent( event );

        assert.equal( spy.callCount, 0, "_getData is not called" );

        spy.restore();
      } );

    } );

    suite( "_checkFinancialErrors", () => {

      var sampleData;

      setup( () => {
        sampleData = {
          "data": {
            "cols": [],
            "rows": [{
              "c": [{ "v": "" }, { "v": 0 }, { "v": 0 }, { "v": 0 }, { "v": 0 }]
            }, {
              "c": [{ "v": "" }, { "v": 0 }, { "v": 0 }, { "v": 0 }, { "v": 0 }]
            }]
          }
        }
      } );

      test( "should not log if no status are present in the data", () => {
        const stub = sinon.stub( element, "_log" );

        element._checkFinancialErrors( sampleData );

        assert.isFalse( stub.called );

        stub.restore();
      } );

      test( "should log N/P warning if it's present in the data", () => {
        const stub = sinon.stub( element, "_log" );

        sampleData.data.rows[0].c[0].v = "N/P";

        element._checkFinancialErrors( sampleData );

        assert.isTrue( stub.calledWith(
          "warning",
          "Rise is not permissioned to show the instrument",
          { symbols: element.symbols }
        ));

        stub.restore();
      } );

      test( "should log N/P and S/P error if both are present in the data", () => {
        const stub = sinon.stub( element, "_log" );

        sampleData.data.rows[0].c[0].v = "N/P";
        sampleData.data.rows[1].c[0].v = "S/P";

        element._checkFinancialErrors( sampleData );

        assert.isTrue( stub.calledWith(
          "warning",
          "Rise is not permissioned to show the instrument",
          { symbols: element.symbols }
        ));
        assert.isTrue( stub.calledWith(
          "error",
          "Display is not permissioned to show the instrument",
          { symbols: element.symbols }
        ));

        stub.restore();
      } );

      test( "should log N/A error if it's present in the data", () => {
        const stub = sinon.stub( element, "_log" );

        sampleData.data.rows[0].c[0].v = "N/A";

        element._checkFinancialErrors( sampleData );

        assert.isTrue( stub.calledWith(
          "error",
          "Instrument is unavailable, invalid or unknown",
          { symbols: element.symbols }
        ));

        stub.restore();
      } );

    } );

    suite( "uptime", () => {
      let sandbox = sinon.createSandbox();

      setup( () => {
        sandbox.stub(element.__proto__.__proto__, '_setUptimeError');
      });

      teardown( () => {
        sandbox.restore();
      });

      test("should default to no uptime error", () => {
        assert.isFalse( element._setUptimeError.called );
      });

      test("should set uptime error when raising data-error", () => {
        element._sendFinancialEvent("data-error");
        assert.isTrue( element._setUptimeError.called );
        assert.isTrue( element._setUptimeError.calledWith(true) );
      });

      test("should set uptime error when raising request-error", () => {
        element._sendFinancialEvent("request-error");
        assert.isTrue( element._setUptimeError.called );
        assert.isTrue( element._setUptimeError.calledWith(true) );
      });

      test("should report no uptime error when sending data-update", () => {
        element._sendFinancialEvent("data-update");
        assert.isTrue( element._setUptimeError.called );
        assert.isTrue( element._setUptimeError.calledWith(false) );
      });

      test("should not change uptime error status on other events", () => {
        element._sendEvent("configured");
        assert.isFalse( element._setUptimeError.called );
      });

    });

  });
</script>

</body>
</html>
