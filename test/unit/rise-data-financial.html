<!doctype html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../node_modules/wct-browser-legacy/browser.js"></script>
  <script src="../mocks/firebase.js"></script>
  <script type="text/javascript">
    RisePlayerConfiguration = {};
  </script>
  <script src="../../src/rise-data-financial-config.js" type="module"></script>
  <script src="../../src/rise-data-financial.js" type="module"></script>
</head>
<body>
<test-fixture id="test-block">
  <template>
    <rise-data-financial financial-list="Stocks" instrument-fields='["lastPrice", "netChange"]'></rise-data-financial>
  </template>
</test-fixture>

<script src="../data/realtime.js"></script>

<script>
  suite("rise-data-financial", () => {

    const fields = [ "lastPrice", "netChange" ],
      inst1 = {
        category: "Stocks",
        index: 0,
        name: "Alcoa",
        symbol: "AA.N",
        $id: "AA?N"
      },
      inst2 = {
        category: "Stocks",
        index: 1,
        name: "Dow Jones",
        symbol: ".DJI",
        $id: "?DJI"
      },
      instrument = {
        "AA?N": inst1
      },
      instruments = [
        inst1, inst2
      ];

    let element,
      clock,
      _resetStub;

    setup(() => {
      RisePlayerConfiguration.getDisplayId = () => {
        return "ABC123";
      };

      RisePlayerConfiguration.Logger = {
        info: () => {},
        warning: () => {},
        error: () => {}
      };

      element = fixture("test-block");
      _resetStub = sinon.stub(element, "_reset");

    });

    teardown(() => {
      _resetStub.restore();
      RisePlayerConfiguration.getDisplayId = {};
      RisePlayerConfiguration.Logger = {};
    });

    suiteSetup( () => {
      clock = sinon.useFakeTimers();
    } );

    suiteTeardown( () => {
      clock.restore();
    } );

    suite( "Properties", () => {

      test( "should set financial list property", () => {
        assert.equal( element.financialList, "Stocks" );
      } );

      test( "should set instrument fields array", () => {
        assert.deepEqual( element.instrumentFields, [ "lastPrice", "netChange" ] );
      } );

    } );

    suite( "_isValidType", () => {

      test( "should return true if 'type' attribute is 'realtime'", () => {
        assert.isTrue( element._isValidType( "realtime" ) );
      } );

      test( "should return true if 'type' attribute is 'historical'", () => {
        assert.isTrue( element._isValidType( "historical" ) );
      } );

      test( "should return false when invalid", () => {
        assert.isFalse( element._isValidType( "test" ) );
      } );

    } );

    suite( "_getInstrumentsFromLocalStorage", () => {
      setup( () => {
        localStorage.removeItem( `risedatafinancial_${element.financialList}` );
        localStorage.setItem(
          `risefinancial_${element.financialList}`,
          JSON.stringify( instruments )
        );
      } );

      teardown( () => {
        localStorage.removeItem( `risedatafinancial_${element.financialList}` );
      } );

      test( "should provide instruments from local storage", (done) => {
        element._getInstrumentsFromLocalStorage( `risefinancial_${element.financialList}` )
          .then((data)=>{
            assert.deepEqual( data, instruments );
            done();
          })
          .catch(() => console.log("shouldn't be here"));
      } );

    } );

    suite( "_refresh", () => {

      test( "should make a new request for data after 1 minute", () => {
        const stub = sinon.stub( element, "_getData" );

        element._refresh();

        assert.isFalse( stub.calledOnce );

        clock.tick( 60000 );

        assert.isTrue( stub.calledWith({
          duration: "1M",
          type: "realtime"
        }, element._instruments, [ "lastPrice", "netChange" ]) );

        stub.restore();
      } );

    } );

    suite( "_getInstruments", () => {
      let spy;

      setup( () => {
        spy = sinon.stub( element, "_handleInstruments" );
      } );

      teardown( () => {
        spy.restore();
      } );

      test( "should trigger _handleInstruments() to be executed upon instruments received", () => {
        element._getInstruments();

        assert( spy.calledOnce );
      } );

      test( "should get instruments from local storage if firebase not connected", (done) => {
        clock.restore();

        sinon.stub(element, "_getInstrumentsFromLocalStorage", ()=> {
          return Promise.resolve(instruments);
        });

        element._instrumentsReceived = false;
        element._instruments = undefined;
        element._firebaseConnected = false;

        element._getInstruments();

        setTimeout(() => {
          assert.isTrue( element._instrumentsReceived );
          assert.deepEqual( element._instruments, instruments );

          element._firebaseConnected = true;
          element._getInstrumentsFromLocalStorage.restore();

          clock = sinon.useFakeTimers();

          done();
        }, 500);
      } );

      test( "should send 'instruments-unavailable' event if firebase not connected and localStorage empty", ( done ) => {
        let listener = () => {
          element._getInstrumentsFromLocalStorage.restore();
          element._firebaseConnected = true;
          element._instrumentsReceived = true;
          element.removeEventListener( "instruments-unavailable", listener );
          done();
        };

        sinon.stub( element, "_getInstrumentsFromLocalStorage", () => {
          return Promise.reject();
        } );

        element._instrumentsReceived = false;
        element._firebaseConnected = false;

        element.addEventListener( "instruments-unavailable", listener );
        element._getInstruments();
      } );

      test( "should not trigger _handleInstruments() if no financialList attribute", () => {
        element.financialList = "";
        element._getInstruments();

        assert.equal( spy.callCount, 0 );

        element.financialList = "Stocks";
      } );

      test( "should not trigger _handleInstruments() if firebase connection status not determined", () => {
        element._firebaseConnected = undefined;
        element._getInstruments();

        assert.equal( spy.callCount, 0 );

        element._firebaseConnected = true;
      } );

    } );

    suite( "_handleInstruments", () => {

      test( "should set _instruments and send 'instruments-received' event", ( done ) => {
        let listener = () => {
          element.removeEventListener( "instruments-received", listener );

          assert.deepEqual( element._instruments, [ inst1 ] );

          done();
        };

        element.addEventListener( "instruments-received", listener );

        element._handleInstruments( {
          val: () => {
            return instrument;
          }
        } );
      } );

      test( "should set _instruments to empty array and send 'instruments-received' event", ( done ) => {
        let listener = () => {
          element.removeEventListener( "instruments-received", listener );

          assert.deepEqual( element._instruments, [] );

          done();
        };

        element.addEventListener( "instruments-received", listener );

        element._handleInstruments( {
          val: () => {
            return null;
          }
        } );

      } );

    } );

    suite( "_saveInstruments", () => {

      setup( () => {
        localStorage.removeItem( `risedatafinancial_${element.financialList}` );
      } );

      teardown( () => {
        localStorage.removeItem( `risedatafinancial_${element.financialList}` );
      } );

      test( "should save instruments to local storage", () => {
        element._saveInstruments( [ inst1 ] );

        assert.deepEqual( JSON.parse( localStorage.getItem( `risedatafinancial_${element.financialList}` ) ),
          [ inst1 ] ); // eslint-disable-line quotes
      } );

    } );

    suite( "_getParams", () => {

      test( "should return query parameters object", () => {

        const callback = ( btoa( "request" + element._getKey() ) ).substr( 0, 10 ) + Math.random(),
          expected = {
            id: "ABC123",
            code: inst1.symbol,
            tq: "select lastPrice,netChange",
            tqx: "out:json;responseHandler:" + callback,
          };

        assert.deepEqual( element._getParams( fields, inst1.symbol, callback ), expected );
      } );

      test( "should return query parameters object with no 'tq' property", () => {
        const callback = ( btoa( "request" + element._getKey() ) ).substr( 0, 10 ) + Math.random(),
          expected = {
            id: "ABC123",
            code: inst1.symbol,
            tqx: "out:json;responseHandler:" + callback,
          };

        assert.deepEqual( element._getParams( [], inst1.symbol, callback ), expected );
      } );

    } );

    suite( "_getQueryString", () => {

      test( "should return query string for fetching a specific set of fields", () => {
        const expected = "select lastPrice,netChange";

        assert.equal( element._getQueryString( fields ), expected );
      } );

      test( "should return empty string if no parameter specified", () => {
        assert.equal( element._getQueryString( [] ), "" );
      } );

    } );

    suite( "_getSymbols", () => {

      teardown( () => {
        element.setAttribute( "symbol", "" );
        element._invalidSymbol = false;
      } );

      test( "should return empty string if no instruments", () => {
        assert.equal( element._getSymbols( [] ), "" );
      } );

      test( "should return string of instrument symbols separated by |", () => {
        assert.equal( element._getSymbols( instruments ), "AA.N|.DJI" );
      } );

      test( "should return only the single symbol if the symbol attribute is set and it is within the list of instruments", () => {
        element.setAttribute( "symbol", ".DJI" );
        assert.equal( element._getSymbols( instruments ), ".DJI" );
      } );

      test( "should set invalidSymbol and send 'invalid-symbol' event", ( done ) => {
        let listener = () => {
          element.removeEventListener( "invalid-symbol", listener );

          assert.isTrue( element._invalidSymbol );

          done();
        };

        element.addEventListener( "invalid-symbol", listener );

        element.setAttribute( "symbol", ".TEST" );
        assert.equal( element._getSymbols( instruments ), "" );
      } );

    } );

    suite( "_getKey()", () => {

      test( "should return correct key value when configured with defaults and without symbol", () => {
        const expected = `risedatafinancial_${element.type}_${element.displayId}_${element.financialList}_${element.duration}_`;
        assert.equal( element._getKey(), expected );
      } );

      test( "should return correct key value when configured different from defaults and with symbol", () => {
        element.symbol = instrument.symbol;
        element.type = "historical";
        element.duration = "week";

        const expected = `risedatafinancial_${element.type}_${element.displayId}_${element.financialList}_${element.duration}_${element.symbol}`;
        assert.equal( element._getKey(), expected );
      } );

    });

    suite( "_getSerializedUrl", () => {

      test( "should return a serialized url with query params", () => {
        const callback = element._getCallbackValue( element._getKey() ),
          params = {
            id: "ABC123",
            code: inst1.symbol,
            tq: "select lastPrice,netChange",
            tqx: "out:json;responseHandler:" + callback,
          },
          expected = `https://contentfinancial2.appspot.com/data?id=ABC123&code=AA.N&tq=select%20lastPrice%2CnetChange&tqx=out%3Ajson%3BresponseHandler%3A${callback}`;

        assert.equal( element._getSerializedUrl( "https://contentfinancial2.appspot.com/data", params ), expected );
      } );

    });

    suite( "_getData", () => {

      const props = {
          type: "realtime",
          duration: "1M",
        };

      test( "should not execute if component configured with an invalid type", () => {
        const stub = sinon.stub( element, "_getSymbols" );

        element._getData( { type: "invalid", duration: "1M" }, instruments, [] );

        assert.isFalse( stub.called );

        stub.restore();
      } );

      test( "should not execute if component configured for historical with an invalid duration", () => {
        const stub = sinon.stub( element, "_getSymbols" );

        element._getData( { type: "historical", duration: "invalid" }, instruments, [] );

        assert.isFalse( stub.called );

        stub.restore();
      } );

      test( "should call '_getSerializedUrl()' with realtime financial test server url", () => {
        const stub = sinon.stub( element, "_getSerializedUrl" );

        element._getData( props, instruments, [] );

        assert.equal( stub.args[0][0], "https://contentfinancial2-test.appspot.com/data" );

        stub.restore();
      } );

      test( "should call '_getSerializedUrl()' with historical financial test server url", () => {
        const stub = sinon.stub( element, "_getSerializedUrl" );

        props.type = "historical";
        element._getData( props, instruments, [] );

        assert.equal( stub.args[0][0], "https://contentfinancial2-test.appspot.com/data/historical" );

        props.type = "realtime";
        stub.restore();
      } );

      test( "should call '_getSerializedUrl()' with correct params for single instrument", () => {
        const stub = sinon.stub( element, "_getSerializedUrl" );

        const expected = {
          id: "ABC123",
          code: "AA.N",
          tq: "select lastPrice,netChange"
        };

        element._getData( props, [ inst1 ], fields );
        assert.equal( stub.args[0][1].id, expected.id );
        assert.equal( stub.args[0][1].code, expected.code );
        assert.equal( stub.args[0][1].tq, expected.tq );
        assert.include( stub.args[0][1].tqx, "out:json;responseHandler:" );

        stub.restore();
      } );

      test( "should call '_getSerializedUrl()' with correct params for multiple instruments", () => {
        const stub = sinon.stub( element, "_getSerializedUrl" );

        const expected = {
          id: "ABC123",
          code: "AA.N|.DJI",
          tq: "select lastPrice,netChange"
        };

        element._getData( props, instruments, fields );

        assert.equal( stub.args[0][1].id, expected.id );
        assert.equal( stub.args[0][1].code, expected.code );
        assert.equal( stub.args[0][1].tq, expected.tq );
        assert.include( stub.args[0][1].tqx, "out:json;responseHandler:" );

        stub.restore();
      } );

      test( "should not execute request if symbol is invalid", () => {
        const stub = sinon.stub( element, "_getSerializedUrl" );

        element.setAttribute( "symbol", ".YYY" );
        element._getData( props, instruments, fields );

        assert.isFalse( stub.called );

        stub.restore();
      } );

    } );

    suite( "_handleData", () => {
      setup( () => {
        element._instruments = instruments;
      } );

      teardown( () => {
        element._instruments = [];
        element.removeAttribute( "symbol" );
      } );

      test( "should send 'data-update' event with instruments and data", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            instruments: instruments,
            data: realTimeData.table,
          } );

          element.removeEventListener( "data-update", listener );
          done();
        };

        element.addEventListener( "data-update", listener );
        element._handleData( { detail: [ realTimeData ] } );
      } );

      test( "should send 'data-update' event with instruments and data for a single instrument when symbol is set", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            instruments: [ inst2 ],
            data: realTimeData.table,
          } );

          element.removeEventListener( "data-update", listener );
          done();
        };

        element.setAttribute( "symbol", ".DJI" );
        element._invalidSymbol = false;
        element._instruments = instruments;

        element.addEventListener( "data-update", listener );
        element._handleData( { detail: [ realTimeData ] } );
      } );

      test( "should send 'data-update' event with instruments only when no table provided", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            instruments: instruments
          } );

          element.removeEventListener( "data-update", listener );
          done();
        };

        element.addEventListener( "data-update", listener );
        element._handleData( { detail: [ {} ] } );
      } );

      test( "should send 'data-error' event with detail when 'errors' prop present in response detail", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            detailed_message: "400: Test error message",
            message: "Test error message"
          } );

          element.removeEventListener( "data-error", listener );
          done();
        };

        element.addEventListener( "data-error", listener );
        element._handleData( { detail: [ { errors: [ { detailed_message: "400: Test error message", message: "Test error message" } ] } ] } );
      } );

    } );

    suite( "_handleError", () => {

      setup(() => element._initialStart = false);

      test( "should send 'request-error' event with message provided from iron-jsonp-library", ( done ) => {
        const listener = ( evt ) => {
          assert.deepEqual( evt.detail, {
            message: "Test error message"
          } );

          element.removeEventListener( "request-error", listener );
          done();
        };

        element.addEventListener( "request-error", listener );
        element.financialErrorMessage = "Test error message";
      } );

    } );

    suite( "_reset", () => {
      let instrumentsStub;

      setup( () => {
        instrumentsStub = sinon.stub( element, "_getInstruments" );
      } );

      teardown( () => {
        instrumentsStub.restore();
      } );

      test( "should call _getInstruments() if not initial start", () => {
        // need to remove the stub and add back on every test
        _resetStub.restore();
        element._initialStart = false;
        element._logDataUpdate = false;
        element._reset();

        assert.isTrue( element._getDataPending );
        assert.isTrue( element._logDataUpdate );
        assert.isTrue( instrumentsStub.calledOnce );

        _resetStub = sinon.stub( element, "_reset" );
      } );

    } );

    suite( "_handleConnected", () => {
      let stub;

      setup( () => {
        stub = sinon.stub( element, "_getInstruments" );
      } );

      teardown( () => {
        stub.restore();
        setFirebaseConnectionStatus( true );
      } );

      test( "should set firebase connected status and call '_getInstruments()' when still needing instruments", () => {
        element._instrumentsReceived = false;
        setFirebaseConnectionStatus( true );

        assert.isTrue( stub.calledOnce );
        assert.isTrue( element._firebaseConnected );

        element._instrumentsReceived = true;
      } );

      test( "should not call '_getInstruments()' if instruments already received", () => {
        setFirebaseConnectionStatus( true );

        assert.equal( stub.callCount, 0 );
        assert.isTrue( element._firebaseConnected );
      } );

      test( "should call '_getInstruments()' if no connection within 2 seconds and still needing instruments", () => {
        element._instrumentsReceived = false;
        setFirebaseConnectionStatus( false );

        clock.tick( 2000 );

        assert.isTrue( stub.calledOnce );
        assert.isFalse( element._firebaseConnected );

        element._firebaseConnected = true;
      } );

    } );

    suite( "ready", () => {
      test( "should set display id when a valid display id is provided", () => {
        assert.equal( element.displayId, "ABC123" );
      } );
    } );

    suite( "_handleStart", () => {

      test( "should call _getData() when this is the initial 'start'", () => {
        const stub = sinon.stub( element, "_getData" );

        element._instrumentsReceived = true;

        const event = new CustomEvent( "start" );
        element.dispatchEvent( event );

        assert.isTrue( stub.calledWith({
          duration: "1M",
          type: "realtime"
        }, element._instruments, [ "lastPrice", "netChange" ]) );

        assert.isFalse( element._initialStart, "_initialStart set to false" );

        stub.restore();
      } );

      test( "should call _getData() when this is not the initial 'start' but _getDataPending is true", () => {
        const stub = sinon.stub( element, "_getData" );

        element._instrumentsReceived = true;
        element._getDataPending = true;

        const event = new CustomEvent( "start" );
        element.dispatchEvent( event );

        assert.isTrue( stub.calledWith({
          duration: "1M",
          type: "realtime"
        }, element._instruments, [ "lastPrice", "netChange" ]) );

        assert.isFalse( element._initialStart, "_initialStart set to false" );

        stub.restore();
      } );

      test( "should not call _getData() when this is not the initial start and _getDataPending is false", () => {
        const spy = sinon.stub( element, "_getData" );

        element._instrumentsReceived = true;
        element._initialStart = false;

        const event = new CustomEvent( "getData" );
        element.dispatchEvent( event );

        assert.equal( spy.callCount, 0, "_getData is not called" );

        spy.restore();
      } );

    } );

  });
</script>

</body>
</html>
